* 基础知识
** 算法与数据结构与设计
*** 手写lru
*** 如何讲一个文件快速下发到100w个服务器
*** 实现一个二叉树持久化方案
*** 50亿个整数中，找一个确定的数（有内存限制，并且无序）
*** 找一个字符串中第一个不重复的字符
*** 给你两个球，100层楼，每个球在一定高度扔下去，怎么用最少的次数判断是几层楼能把球摔碎？
*** 洗牌发牌算法
*** 数组存水
*** 所有排序算法与其稳定度
*** 求一个集合的所有子集
*** 去除包含4的数字求一个数是第几个数
*** 有一个楼梯，一共有n层，可以走a与b步，问最高到几层（如果有一次能回退一半，比如从8层到4层呢？ 用两次dp）
*** 如何保证单例模式只有一个实例
*** 100万条数据，每次请求查询时怎么最快，想多种方法，红黑树，hash等
*** 大数排序
*** 每一个元素右边第一个最大元素
*** 扑克牌随机打乱
*** 两个十万数量组的整数组，求其交集
*** 给一个长为n的数字，往里面插入k个乘号，求最大可能的乘积
*** 最长连续子序列
*** kmp字符串匹配
*** 最长回文串
*** 求第k大的数的方法与各自复杂度
*** 取中位数的方法与其复杂度
*** 素数求法
*** 大文本如何排序
*** 一个数据流只访问一次，如何保证访问每个数据的频率相同
*** 如何设计一个分布式配置系统，更新配置后1秒内同步分发给客户端
*** 1/x + 1/y = 1/n求最小的n，使xy对数超过1000
*** 如何制作一个游戏，当用户到达一个视野后更新怪物，怪物有愤怒值，怎么去设定这件事
*** 字符串去空 
*** 16进制转10进制
*** 求前100大的数（堆与快排的分割函数各自复杂度）
*** 链表翻转
*** 哈夫曼动态压缩过程
*** 判断一树是不是二叉搜索树
*** 最优二叉树
*** 栈、队列之间相互模拟
*** kmeans
*** 红黑树
*** avl树
*** b树b+树，及其区别
*** hash
** 设计模式
*** 装饰器模式
装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。
http://www.runoob.com/design-pattern/decorator-pattern.html
*** 单例模式
*** 观察者模式
** 网络
*** osi七层模型与tcp/ip四层模型，每卖劲列举两个协议
*** 客户端向服务器发3个包基于tcp与udp的服务器会收到几个？尽可能考虑到所有情况
*** 浏览器输入地址后发生的全过程
*** dns
*** http
**** get post区别
*** tcp/udp各自使用场景
*** tcp/ip
**** 有什么字段，什么用
**** 可靠性怎么保证
**** 网络拥堵控制
**** 三次握手  多一次少一次会怎样
**** 四次挥手   同上
**** ip mac地址 arp rarp协议
**** TIME——WAIT状态分析
*** http与https
*** http返回码
*** nat协议
** 加密与安全
*** 数字证书机制
*** 加密方法

*** xss原理
** 系统
*** 协程
*** 僵尸进程，守护进程？？？？查下定义用什么调用产生
*** 讲讲同步异步阻塞非阻塞
*** linux如何从磁盘找文件
*** 进程与线程区别
*** 进程状态，切换
？？动态就绪，静态就绪，动态阻塞，静态阻塞
*** 并发与并行
*** 缺页，页表
*** linux fork 与vfork
*** 多进程更安全，多线程的话，一个线程死掉，所有线程死掉，进程崩溃
*** 系统中断
*** 用户态与内核态的区别
*** 段错误的原因
*** 多进程与多线程的同步方式
*** 锁
*** 系统调用时发生的事
*** 进程间通信方法
*** 什么是死锁，如何解决死锁
*** 信号
https://sustyuxiao.github.io/2018/04/08/2018-04-08/
*** linux系统权限
*** linux线程的实现方式
*** linux如何扩大分区
*** epoll libev优点
*** epoll、select、poll异同
*** 讲一下有名管道与无名管道与UNIX domain sockets
1、无名管道

   无名管道是Linux中管道通信的一种原始方法，如图一(左)所示，它具有以下特点：

   ①  它只能用于具有亲缘关系的进程之间的通信（也就是父子进程或者兄弟进程之间）；

   ②  它是一个半双工的通信模式，具有固定的读端和写端；

   ③   管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read()、write()等函数。但它不是普通的文件，并不属于其他任何文件系统并且只存在于内存中。

2、有名管道(FIFO)

    有名管道是对无名管道的一种改进，如图1(右)所示，它具有以下特点：

    ①  它可以使互不相关的两个进程间实现彼此通信；

    ②  该管道可以通过路径名来指出，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当做普通文件一样进行读写操作，使用非常方便；

    ③  FIFO严格地遵循先进先出规则，对管道及FIFO的读总是从开始处返回数据，对它们的写则是把数据添加到末尾，它们不支持如 lseek()等文件定位操作。

   管道是基于文件描述符的通信方式，当一个管道建立时，它会创建两个文件描述符fd[0]和fd[1]，其中fd[0]固定用于读管道，而fd[1]固定用于写管道，如图2所示，这样就构成了一个半双工的通道。
   管道关闭时只需要将这两个文件描述符关闭即可，可使用普通的close()函数逐个关闭各个文件描述符。
3 unix domain sockets

       The AF_UNIX (also known as AF_LOCAL) socket family is used to
       communicate between processes on the same machine efficiently.
       Traditionally, UNIX domain sockets can be either unnamed, or bound to
       a filesystem pathname (marked as being of type socket).  Linux also
       supports an abstract namespace which is independent of the
       filesystem.

**** 什么时候select比epoll好
**** epoll两种触发方式
** c/c++语言
*** 整个编译运行流程
*** 栈空间最大值
*** 四种cast各有什么用
*** 如果析构函数抛出异常怎么办
*** 宏与枚举的区别
*** 构造函数为什么不能定义为虚函数，析构函数为什么一般定义为虚函数
*** iterator category
*** 如果不想一个类被继承，怎么办
*** 如何给指定物理地址赋值，如何跳转到指定物理地址执行
*** struct内存对齐方式
*** 引用与指针的区别
*** memcpy与memmove
memcpy 不考虑内存重叠问题，效率高，（如已知两块内存不会重叠），memcpy更合适
memmove考虑内存重叠问题。在dest头部在src范围内时：src的尾部在复制中被修改会出错，memmove加了一次判断，在这种情况下会逆序复制
*** 获取内存的各种方式（不要忘记栈）
*** malloc与new的区别
*** cout/printf其区别
*** vector<int>怎么扩容
*** 什么模板类放在h文件中
*** stl set map 红黑树
*** stl内存优化
*** 类成员的访问权限，三种不同的继承模式下权限
*** static关键字的作用（对函数，对函数内变量等）
修饰全局变量，变量被称为全局静态变量，存储在静态区
目的：限定作用域为当前文件，其他文件不可访问该变量
修饰局部变量，称为局部静态变量，存储在静态区
目的：函数结束时不销毁，使得下次调用时不需要再次开辟空间，同时保留原内容。虽然生命周期为整个进程，但仍不能被其他函数、变量访问，局部静态变量不可征稿，多线程时要注意线程安全。
修饰函数，使得函数作用域限定在本文件中，不被其他文件访问，达到类似c++ private的效果。
*** c/c++优化方法
*** 如何用c实现c++特性
成员变量与成员函数
使用结构体去封闭一个类，通过函数指针去实现成员函数功能
类外实现构造函数
使用static达到private的效果
子类中定义一个蕨类 的对象，实现对父类的继承，将子类对象地址转为父类指针类型，实现多态
*** 静态变量的初始化时间
*** 栈空间、堆空间、静态区
*** 多态的实现方式
https://sustyuxiao.github.io/2018/03/09/2018-03-09/ 
*** 哪些函数不能是虚函数
*** 多基继承时，二义性问题怎么解决
*** 虚函数实现原理、虚表、菱形继承
*** 异常与return error code的优劣
*** map插入删除要注意什么
*** c++11/14/17新特性
**** future/promise
**** auto deltype
**** shared_ptr weak_ptr unique_ptr
**** forward move
**** lambda实现原理
**** c++17 invoke
*** 重载new？？？
*** RAII lock_guard
*** RTTI
*** c++中可睡眠的锁
*** 模板成员函数能否是虚函数
*** stl库分为哪几块
*** 讲一下泛型编程
本质为类型参数化，实现代码利用
具体解决了如下问题：
- 类型安全，编译器可以做检查，不再用void*
- 通用性，实现代码复用
- 接口的直观性，参数简洁
- 效率， sort的第二个参数comp为仿函数时，将对仿函数调用内联，减少函数调用开销。
** database
*** 索引的实现方式
*** 事务的实现方式
*** 三大范式
*** sql优化方法
*** 数据库的裊
** misc
*** 查看函数用的内存
*** 查看进程、线程、函数的cpu占用
*** mongodb与mysql差别，sql、nosql区别使用场景
*** 内存泄漏怎么解决 
* 项目
* blog
* 分布式系统
** 分布式系统分片极限
** 怎么解决副本一致
** 分布式缓存设计
** 配置中心怎么开发
** zookeeper原理
** 二次提交等保证分布式一致性的算法
为了解决这种分布式一致性问题，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有二阶提交协议（Two Phase Commitment Protocol）、三阶提交协议（Three Phase Commitment Protocol）和Paxos算法。
** 大数据架构（kafka storm spark)
* 工具框架源码阅读
** redis
*** redis集群最大能支撑多少物理机
*** 性能瓶颈，主流公司的网络框架
*** redis cluster原理
 cluster的原理，是基于分片。一个 Redis cluster集群包含 16384 个哈希槽, 任意一个key都可以通过 CRC16(key) % 16384 这个公式计算出应当属于哪个槽。每个槽应当落在哪个节点上，也是事先定好。这样，进行任一操作时，首先会根据key计算出对应的节点，然后操作相应的节点就可以了。所以说，其实cluster跟单点相比，只是多了一个给key计算sharding值的过程，并没有增加多少复杂度，个人认为完全可以放心使用。像增删节点、重启这些对redis本身的操作，和client端对数据的操作，是两套流程，可以做到互不干扰。关于节点故障，一是有slave，二是即便这一个节点完全挂掉，也只是落在这个节点上的数据不可用，不会有类似“雪崩”这样的问题影响整个集群。数据的恢复之类的逻辑，也与单点完全一致，是独立于集群其他部分的。redis cluster的整个设计是比较简单的，并没有引入太多新问题，大部分操作都可以按照单点的操作流程进行操作。至于cluster最终的易用性，其实很大程度上取决client端的代码可靠性，而jedis现在的代码也已经很完善了，用起来也比较方便。
** mongodb
*** 索引
** bigtable mapreduce
** gdb
** mysql
*** 常用的引擎
*** 索引
*** 四种隔离状态
** awk
** 
