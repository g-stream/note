* 基础知识
** 算法与数据结构与设计
*** 手写lru
*** 如何讲一个文件快速下发到100w个服务器
*** 实现一个二叉树持久化方案
*** 50亿个整数中，找一个确定的数（有内存限制，并且无序）
*** 找一个字符串中第一个不重复的字符
*** 给你两个球，100层楼，每个球在一定高度扔下去，怎么用最少的次数判断是几层楼能把球摔碎？
*** 洗牌发牌算法
*** 数组存水
*** 所有排序算法与其稳定度
*** 求一个集合的所有子集
*** 去除包含4的数字求一个数是第几个数
*** 有一个楼梯，一共有n层，可以走a与b步，问最高到几层（如果有一次能回退一半，比如从8层到4层呢？ 用两次dp）
*** 如何保证单例模式只有一个实例
*** 100万条数据，每次请求查询时怎么最快，想多种方法，红黑树，hash等
*** 大数排序
*** 每一个元素右边第一个最大元素
*** 扑克牌随机打乱
*** 两个十万数量组的整数组，求其交集
*** 给一个长为n的数字，往里面插入k个乘号，求最大可能的乘积
*** 最长连续子序列
*** kmp字符串匹配
*** 最长回文串
*** 求第k大的数的方法与各自复杂度
*** 取中位数的方法与其复杂度
*** 素数求法
*** 大文本如何排序
*** 一个数据流只访问一次，如何保证访问每个数据的频率相同
*** 如何设计一个分布式配置系统，更新配置后1秒内同步分发给客户端
*** 1/x + 1/y = 1/n求最小的n，使xy对数超过1000
*** 如何制作一个游戏，当用户到达一个视野后更新怪物，怪物有愤怒值，怎么去设定这件事
*** 字符串去空 
*** 16进制转10进制
*** 求前100大的数（堆与快排的分割函数各自复杂度）
*** 链表翻转
*** 哈夫曼动态压缩过程
*** 判断一树是不是二叉搜索树
*** 最优二叉树
*** 栈、队列之间相互模拟
*** kmeans
*** 红黑树
*** avl树
*** b树b+树，及其区别
*** hash
** 设计模式
*** 装饰器模式
装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。
http://www.runoob.com/design-pattern/decorator-pattern.html
*** 单例模式
*** 观察者模式
** 网络
*** osi七层模型与tcp/ip四层模型，每卖劲列举两个协议
*** 客户端向服务器发3个包基于tcp与udp的服务器会收到几个？尽可能考虑到所有情况
*** 浏览器输入地址后发生的全过程
*** dns
*** http
**** get post区别
*** tcp/udp各自使用场景
*** tcp/ip
**** 有什么字段，什么用
**** 可靠性怎么保证
**** 网络拥堵控制
**** 三次握手  多一次少一次会怎样
**** 四次挥手   同上
**** ip mac地址 arp rarp协议
**** TIME——WAIT状态分析
*** http与https
*** http返回码
*** nat协议
** 加密与安全
*** 数字证书机制
*** 加密方法

*** xss原理
** 系统
*** 协程
*** 僵尸进程，守护进程？？？？查下定义用什么调用产生
*** 讲讲同步异步阻塞非阻塞
*** linux如何从磁盘找文件
*** 进程与线程区别
*** 进程状态，切换
？？动态就绪，静态就绪，动态阻塞，静态阻塞
*** 并发与并行
*** 缺页，页表
*** linux fork 与vfork
*** 多进程更安全，多线程的话，一个线程死掉，所有线程死掉，进程崩溃
*** 系统中断
*** 用户态与内核态的区别
*** 段错误的原因
*** 多进程与多线程的同步方式
*** 锁
*** 系统调用时发生的事
*** 进程间通信方法
*** 什么是死锁，如何解决死锁
*** 信号
https://sustyuxiao.github.io/2018/04/08/2018-04-08/
*** linux系统权限
*** linux线程的实现方式
*** linux如何扩大分区
*** epoll libev优点
*** epoll、select、poll异同
*** 讲一下有名管道与无名管道与UNIX domain sockets
1、无名管道

   无名管道是Linux中管道通信的一种原始方法，如图一(左)所示，它具有以下特点：

   ①  它只能用于具有亲缘关系的进程之间的通信（也就是父子进程或者兄弟进程之间）；

   ②  它是一个半双工的通信模式，具有固定的读端和写端；

   ③   管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read()、write()等函数。但它不是普通的文件，并不属于其他任何文件系统并且只存在于内存中。

2、有名管道(FIFO)

    有名管道是对无名管道的一种改进，如图1(右)所示，它具有以下特点：

    ①  它可以使互不相关的两个进程间实现彼此通信；

    ②  该管道可以通过路径名来指出，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当做普通文件一样进行读写操作，使用非常方便；

    ③  FIFO严格地遵循先进先出规则，对管道及FIFO的读总是从开始处返回数据，对它们的写则是把数据添加到末尾，它们不支持如 lseek()等文件定位操作。

   管道是基于文件描述符的通信方式，当一个管道建立时，它会创建两个文件描述符fd[0]和fd[1]，其中fd[0]固定用于读管道，而fd[1]固定用于写管道，如图2所示，这样就构成了一个半双工的通道。
   管道关闭时只需要将这两个文件描述符关闭即可，可使用普通的close()函数逐个关闭各个文件描述符。
3 unix domain sockets

       The AF_UNIX (also known as AF_LOCAL) socket family is used to
       communicate between processes on the same machine efficiently.
       Traditionally, UNIX domain sockets can be either unnamed, or bound to
       a filesystem pathname (marked as being of type socket).  Linux also
       supports an abstract namespace which is independent of the
       filesystem.

**** 什么时候select比epoll好
**** epoll两种触发方式
** c/c++语言
*** 整个编译运行流程
1.预处理(Preprocessing), 2.编译(Compilation), 3.汇编(Assemble), 4.链接(Linking)。
1. 将所有的#include头文件以及宏定义替换成其真正的内容
   - 宏定义指令
如#define Pi 3.1415，预处理阶段会将程序中所有的Pi用3.1415代替。与之对应的#undef    则会取消对某个宏的定义，使之后面出现时不再被替换。
   - 条件编译指令
如#ifdef、#ifndef、#else、#elif、#endif等伪指令的引入可以使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理，即预处理阶段将根据有关的文件将不必要的代码过滤掉。
   - 头文件包含指令
如#include，头文件中一般通过#define定义了一些宏（如字符常量），同时也包含了各种外部符号的声明。采用头文件可以使一些定义在多个不同的C源程序中使用，而不必在文件中重新定义。预处理阶段会将头文件中的定义加入到引用它的代码中。
   - 特殊符号
如在源程序中出现的FUNCTION会被解释为当前被编译的C源程序中的函数名称。预处理阶段会对源程序中出现的这些特殊符号用合适的值进行替换。
2. 将经过预处理之后的程序转换成特定汇编代码
编译阶段所有做的工作就是通过词法分析和语法分析，在确认所有指令都符合语法规则之后，将其翻译成等价的中间代码或者是汇编代码。
字符流 到 词法分析器生成token，语法分析器，解析成抽象语法树。其中还涉及到优化：
编译阶段会对代码进行优化处理，不仅涉及到编译技术本身，还涉及到机器的硬件环境。优化分为两部分：
不依赖于具体计算机的优化。主要是删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制、已知量的合并等）、无用赋值的删除等
同机器硬件结构相关的优化。主要考虑如何充分利用机器的硬件寄存器存放的有关变量的值以减少内存的访问次数；根据机器硬件执行指令的特点对指令进行调整使目标代码比较短，执行效率更高等。
llvm中间ir生成各种平台的优化后的代码。clang作为前端解析生成中间ir。
3. 汇编过程将上一步的汇编代码转换成机器码(machine code)
4. 链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)
*** 动态库静态库
*** 栈空间最大值
ulimits -a 
结果8m
*** 四种cast各有什么用
const_cast
这个转换类型操纵传递对象的const属性，或者是设置或者是移除：

'reinterpret_cast'转换一个指针为其它类型的指针。它也允许从一个指针转换为整数类型。反之亦然。（译注：是指针具体的地址值作为整数值？）
这个操作符能够在非相关的类型之间转换。操作结果只是简单的从一个指针到别的指针的值的二进制拷贝。在类型之间指向的内容不做任何类型的检查和转换。


'static_cast'允许执行任意的隐式转换和相反转换动作。（即使它是不允许隐式的）
应用到类的指针上，意思是说它允许子类类型的指针转换为父类类型的指针（这是一个有效的隐式转换），同时，也能够执行相反动作：转换父类为它的子类。


'dynamic_cast'只用于对象的指针和引用。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。不过，与static_cast不同，在后一种情况里（注：即隐式转换的相反过程），dynamic_cast会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。
检测在运行时进行。如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL.
作用：将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理，（因为类信息保存在虚表中，故必须有虚函数的类才能这么用）
       即会作一定的判断。 
       对指针进行dynamic_cast，失败返回null，成功返回正常cast后的对象指针； 
       对引用进行dynamic_cast，失败抛出一个异常，成功返回正常cast后的对象引用。 
注意：dynamic_cast在将父类cast到子类时，父类必须要有虚函数。例如在下面的代码中将CBasic类中的test函数不定义成 

*** 如果析构函数抛出异常怎么办
*** 宏与枚举的区别
（1）从处理过程的角度看：
#define宏是由编译预处理器在预编译处理时处理的，而且只做简单的字符串的替换。枚举常量则是在编译的时候确定其值的。
（2）从调试的角度看：
通常情况下，在编译器里，可以调试枚举常量，而不能调试宏常量。
（3）从数据的类型看：
#define可以编译任意类型的常量，而枚举只能是定义整型常量。
（4）从代码编写角度看：
枚举可以一次定义大量常量，而#define宏只能一次定义一个。
（5）从可维护性来看：
枚举可以集中管理数据，具相同属性的整形数据可使用枚举，枚举可实现取值的自增，也可指定每个枚举的值，编写代码跟容易，相对来说能减少出错的机会，也便于代码的后期维护和修改。
（6）枚举的取值范围已经限定了，容易进行参数的检查，而define没有这种检查
（7）宏定义的默认作用域为整个文件，如果定义了宏定义结尾的地方，作用域就到那个地方；这里有一个潜在的危险，如果我们的头文件中包含了宏定义，此时会导致宏定义没有按照程序员的意愿而产生了范围扩展，当在另外的文件中有了相同的宏定义以后，就会产生冲突导致编译无法通过。
*** 构造函数为什么不能定义为虚函数，析构函数为什么一般定义为虚函数
*** iterator category
*** 如果不想一个类被继承，怎么办
*** 如何给指定物理地址赋值，如何跳转到指定物理地址执行
*** struct内存对齐方式
*** 引用与指针的区别
*** memcpy与memmove
memcpy 不考虑内存重叠问题，效率高，（如已知两块内存不会重叠），memcpy更合适
memmove考虑内存重叠问题。在dest头部在src范围内时：src的尾部在复制中被修改会出错，memmove加了一次判断，在这种情况下会逆序复制
*** 获取内存的各种方式（不要忘记栈）
*** malloc与new的区别
*** cout/printf其区别
*** vector<int>怎么扩容
*** 什么模板类放在h文件中
*** stl set map 红黑树
*** stl内存优化
*** 类成员的访问权限，三种不同的继承模式下权限
*** static关键字的作用（对函数，对函数内变量等）
修饰全局变量，变量被称为全局静态变量，存储在静态区
目的：限定作用域为当前文件，其他文件不可访问该变量
修饰局部变量，称为局部静态变量，存储在静态区
目的：函数结束时不销毁，使得下次调用时不需要再次开辟空间，同时保留原内容。虽然生命周期为整个进程，但仍不能被其他函数、变量访问，局部静态变量不可征稿，多线程时要注意线程安全。
修饰函数，使得函数作用域限定在本文件中，不被其他文件访问，达到类似c++ private的效果。
*** c/c++优化方法
*** 如何用c实现c++特性
成员变量与成员函数
使用结构体去封闭一个类，通过函数指针去实现成员函数功能
类外实现构造函数
使用static达到private的效果
子类中定义一个蕨类 的对象，实现对父类的继承，将子类对象地址转为父类指针类型，实现多态
*** 静态变量的初始化时间
*** 栈空间、堆空间、静态区
BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。

数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量与static变量的一块内存区域。数据段属于静态内存分配。
       .data用于存放初始化过的全局变量。若全局变量值为0，为了优化编译器会将它放在.bss段中
常量数据段(.rodata)：
  ro表read only，用于存放不可变修改的常量数据，一旦程序中对其修改将会出现段错误：
  (1) 程序中的常量不一定就放在rodata中，有的立即数和指令编码放在.text中
  (2) 对于字符串常量，若程序中存在重复的字符串，编译器会保证只存在一个
  (3) rodata是在多个进程间共享的
  (4) 有的嵌入式系统，rodata放在ROM(或者NOR FLASH)中，运行时直接读取无需加载至RAM( 哈佛和冯诺依曼，从STM32的const全局变量说起有所记录)
想要将数据放在.rodata只需要加上const属性修饰即可。

代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）

栈(stack)：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

*** 多态的实现方式
https://sustyuxiao.github.io/2018/03/09/2018-03-09/ 
*** 哪些函数不能是虚函数
*** 多基继承时，二义性问题怎么解决
*** 虚函数实现原理、虚表、菱形继承
*** 异常与return error code的优劣
*** map插入删除要注意什么
*** c++11/14/17新特性
**** future/promise
**** auto deltype
**** shared_ptr weak_ptr unique_ptr
**** forward move
**** lambda实现原理
**** c++17 invoke
*** 重载new？？？
*** RAII lock_guard
*** RTTI

RTTI是Runtime Type Identification的缩写，意思是运行时类型识别。C++引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。但是现在RTTI的类型识别已经不限于此了，它还能通过typeid操作符识别出所有的基本类型（int，指针等）的变量对应的类型。
C++通过以下的两个操作提供RTTI：
（1）typeid运算符，该运算符返回其表达式或类型名的实际类型。
（2）dynamic_cast运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用。
多态类的type_info指针放在虚表的-1位，实现了多态类的类型识别。



*** c++中可睡眠的锁
*** 模板成员函数能否是虚函数
*** stl库分为哪几块
*** 讲一下泛型编程
本质为类型参数化，实现代码利用
具体解决了如下问题：
- 类型安全，编译器可以做检查，不再用void*
- 通用性，实现代码复用
- 接口的直观性，参数简洁
- 效率， sort的第二个参数comp为仿函数时，将对仿函数调用内联，减少函数调用开销。
** database
*** 索引的实现方式
*** 事务的实现方式
*** 三大范式
*** sql优化方法
*** 数据库的裊
** misc
*** 查看函数用的内存
*** 查看进程、线程、函数的cpu占用
*** mongodb与mysql差别，sql、nosql区别使用场景
*** 内存泄漏怎么解决 
* 项目
* blog
* 分布式系统
** 分布式系统分片极限
** 怎么解决副本一致
** 分布式缓存设计
** 配置中心怎么开发
** zookeeper原理
** 二次提交等保证分布式一致性的算法
为了解决这种分布式一致性问题，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有二阶提交协议（Two Phase Commitment Protocol）、三阶提交协议（Three Phase Commitment Protocol）和Paxos算法。
** 大数据架构（kafka storm spark)
* 工具框架源码阅读
** redis
*** redis集群最大能支撑多少物理机
*** 性能瓶颈，主流公司的网络框架
*** redis cluster原理
 cluster的原理，是基于分片。一个 Redis cluster集群包含 16384 个哈希槽, 任意一个key都可以通过 CRC16(key) % 16384 这个公式计算出应当属于哪个槽。每个槽应当落在哪个节点上，也是事先定好。这样，进行任一操作时，首先会根据key计算出对应的节点，然后操作相应的节点就可以了。所以说，其实cluster跟单点相比，只是多了一个给key计算sharding值的过程，并没有增加多少复杂度，个人认为完全可以放心使用。像增删节点、重启这些对redis本身的操作，和client端对数据的操作，是两套流程，可以做到互不干扰。关于节点故障，一是有slave，二是即便这一个节点完全挂掉，也只是落在这个节点上的数据不可用，不会有类似“雪崩”这样的问题影响整个集群。数据的恢复之类的逻辑，也与单点完全一致，是独立于集群其他部分的。redis cluster的整个设计是比较简单的，并没有引入太多新问题，大部分操作都可以按照单点的操作流程进行操作。至于cluster最终的易用性，其实很大程度上取决client端的代码可靠性，而jedis现在的代码也已经很完善了，用起来也比较方便。
** mongodb
*** 索引
** bigtable mapreduce
** gdb
** mysql
*** 常用的引擎
*** 索引
*** 四种隔离状态
** awk
** 
